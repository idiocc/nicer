{
"version":3,
"file":"compile/nicer.js",
"lineCount":389,
"mappings":"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",
"sources":["node_modules/stream/index.js","node_modules/tty/index.js","node_modules/util/index.js","node_modules/@idio/debug/src/ms.js","node_modules/@idio/debug/src/bytes.js","node_modules/erte/src/index.js","node_modules/@idio/debug/src/modifiers/f.js","node_modules/@idio/debug/src/node.js","node_modules/@idio/debug/src/common.js","src/index.js","node_modules/@idio/debug/src/index.js","src/depack.js"],
"sourcesContent":["export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","export default tty\nexport const {\n  ReadStream,\n  WriteStream,\n  isatty,\n} = tty","export default util\nexport const {\n  TextDecoder,\n  TextEncoder,\n  callbackify,\n  debug,\n  debuglog,\n  deprecate,\n  error,\n  format,\n  getSystemErrorName,\n  inherits,\n  inspect,\n  isArray,\n  isBoolean,\n  isBuffer,\n  isDate,\n  isError,\n  isFunction,\n  isNull,\n  isNullOrUndefined,\n  isNumber,\n  isObject,\n  isPrimitive,\n  isRegExp,\n  isString,\n  isSymbol,\n  isUndefined,\n  log,\n  print,\n  promisify,\n  puts,\n} = util","/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar w = d * 7\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {string|number} val\n * @param {Object} [options]\n */\nexport default function(val, options = {}) {\n  var type = typeof val\n  if (type == 'string' && val.length > 0) {\n    const t = /** @type {string} */ (val)\n    return parse(t)\n  } else if (type == 'number' && isFinite(val)) {\n    const n = /** @type {number} */ (val)\n    return options.long ? fmtLong(n) : fmtShort(n)\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  )\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {string} str\n * @api private\n */\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 100) {\n    return\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  )\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n  case 'years':\n  case 'year':\n  case 'yrs':\n  case 'yr':\n  case 'y':\n    return n * y\n  case 'weeks':\n  case 'week':\n  case 'w':\n    return n * w\n  case 'days':\n  case 'day':\n  case 'd':\n    return n * d\n  case 'hours':\n  case 'hour':\n  case 'hrs':\n  case 'hr':\n  case 'h':\n    return n * h\n  case 'minutes':\n  case 'minute':\n  case 'mins':\n  case 'min':\n  case 'm':\n    return n * m\n  case 'seconds':\n  case 'second':\n  case 'secs':\n  case 'sec':\n  case 's':\n    return n * s\n  case 'milliseconds':\n  case 'millisecond':\n  case 'msecs':\n  case 'msec':\n  case 'ms':\n    return n\n  default:\n    return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {number} ms\n * @api private\n */\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms)\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {number} ms\n * @api private\n */\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms)\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day')\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour')\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute')\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second')\n  }\n  return ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '')\n}\n\n/**\n * @license\n * Copyright (c) 2016 Zeit, Inc.\n * https://npmjs.org/ms\n */","/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n\nconst formatThousandsRegExp = /\\B(?=(\\d{3})+(?!\\d))/g\nconst formatDecimalsRegExp = /(?:\\.0*|(\\.[^0]+)0+)$/\n\nconst map = {\n  'b':  1,\n  'kb': 1 << 10,\n  'mb': 1 << 20,\n  'gb': 1 << 30,\n  'tb': Math.pow(1024, 4),\n  'pb': Math.pow(1024, 5),\n}\n\nconst parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i\n\n/**\n * Convert the given value in bytes into a string or parse to string to an integer in bytes.\n *\n * @param {string|number} value\n * @param {{\n *  case: (string|undefined),\n *  decimalPlaces: (number|undefined),\n *  fixedDecimals: (boolean|undefined),\n *  thousandsSeparator: (string|undefined),\n *  unitSeparator: (string|undefined),\n *  }} [options] bytes options.\n *\n * @returns {?(string|number)}\n */\n\nexport default function bytes(value, options) {\n  if (typeof value == 'string') {\n    return parse(value)\n  }\n\n  if (typeof value == 'number') {\n    return format(value, options)\n  }\n\n  return null\n}\n\n/**\n * Format the given value in bytes into a string.\n *\n * If the value is negative, it is kept as such. If it is a float,\n * it is rounded.\n *\n * @param {number} value\n * @param {Object} [options]\n * @param {number} [options.decimalPlaces=2]\n * @param {number} [options.fixedDecimals=false]\n * @param {string} [options.thousandsSeparator=]\n * @param {string} [options.unit=]\n * @param {string} [options.unitSeparator=]\n * @returns {?string}\n */\nexport function format(value, options) {\n  if (!Number.isFinite(value)) {\n    return null\n  }\n\n  const mag = Math.abs(value)\n  const thousandsSeparator = (options && options.thousandsSeparator) || ''\n  const unitSeparator = (options && options.unitSeparator) || ''\n  const decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2\n  const fixedDecimals = Boolean(options && options.fixedDecimals)\n  let unit = (options && options.unit) || ''\n\n  if (!unit || !map[unit.toLowerCase()]) {\n    if (mag >= map['pb']) {\n      unit = 'PB'\n    } else if (mag >= map['tb']) {\n      unit = 'TB'\n    } else if (mag >= map['gb']) {\n      unit = 'GB'\n    } else if (mag >= map['mb']) {\n      unit = 'MB'\n    } else if (mag >= map['kb']) {\n      unit = 'KB'\n    } else {\n      unit = 'B'\n    }\n  }\n\n  const val = value / map[unit.toLowerCase()]\n  let str = val.toFixed(decimalPlaces)\n\n  if (!fixedDecimals) {\n    str = str.replace(formatDecimalsRegExp, '$1')\n  }\n\n  if (thousandsSeparator) {\n    str = str.replace(formatThousandsRegExp, thousandsSeparator)\n  }\n\n  return str + unitSeparator + unit\n}\n\n/**\n * Parse the string value into an integer in bytes.\n *\n * If no unit is given, it is assumed the value is in bytes.\n *\n * @param {number|string} val\n *\n * @returns {number|null}\n * @public\n */\n\nexport function parse(val) {\n  if (typeof val == 'number' && !isNaN(val)) {\n    return val\n  }\n\n  if (typeof val != 'string') {\n    return null\n  }\n\n  // Test if the string passed is valid\n  const results = parseRegExp.exec(val)\n  let floatValue, unit = 'b'\n\n  if (!results) {\n    // Nothing could be extracted from the given string\n    floatValue = parseInt(val, 10)\n    unit = 'b'\n  } else {\n    // Retrieve the value and the unit\n    floatValue = parseFloat(results[1])\n    unit = results[4].toLowerCase()\n  }\n\n  return Math.floor(map[unit] * floatValue)\n}","import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","import { format } from '../bytes'\nimport { c } from 'erte'\n\nexport default {\n  'f': format,\n  'fy'(v) {\n    return c(format(v) || '', 'yellow')\n  },\n  'fr'(v) {\n    return c(format(v) || '', 'red')\n  },\n  'fb'(v) {\n    return c(format(v) || '', 'blue')\n  },\n  'fg'(v) {\n    return c(format(v) || '', 'green')\n  },\n  'fc'(v) { return c(format(v) || '', 'cyan') },\n  'fm'(v) { return c(format(v) || '', 'magenta') },\n}\n","import tty from 'tty'\nimport { inspect, format } from 'util'\nimport ms from './ms'\nimport f from './modifiers/f'\n\nconst colors = [6, 2, 3, 4, 5, 1]\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\nconst inspectOpts = Object.keys(process.env).filter(key => {\n  return /^debug_/i.test(key)\n}).reduce((obj, key) => {\n  // Camel-case\n  const prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, (_, k) => {\n      return k.toUpperCase()\n    })\n\n  // Coerce string value into JS value\n  let val = process.env[key]\n  if (/^(yes|on|true|enabled)$/i.test(val)) {\n    val = true\n  } else if (/^(no|off|false|disabled)$/i.test(val)) {\n    val = false\n  } else if (val === 'null') {\n    val = null\n  } else {\n    val = Number(val)\n  }\n\n  obj[prop] = val\n  return obj\n}, {})\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\nfunction useColors() {\n  return 'colors' in inspectOpts ?\n    Boolean(inspectOpts['colors']) :\n    tty.isatty(process.stderr.fd)\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n * @param {!Array} args\n * @this {_debug.DebugFunction}\n */\nfunction formatArgs(args) {\n  const { namespace, useColors: uc, color, diff } = this\n\n  if (uc) {\n    const c = color\n    const colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c)\n    const prefix = `  ${colorCode};1m${namespace} \\u001B[0m`\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix)\n    args.push(colorCode + 'm+' + ms(diff) + '\\u001B[0m')\n  } else {\n    args[0] = getDate() + namespace + ' ' + args[0]\n  }\n}\n\nfunction getDate() {\n  if (inspectOpts['hideDate']) {\n    return ''\n  }\n  return new Date().toISOString() + ' '\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\nfunction log(...args) {\n  return process.stderr.write(format(...args) + '\\n')\n}\n\n/**\n * Save `namespaces`.\n * @param {string} namespaces\n */\nfunction save(namespaces) {\n  if (namespaces) {\n    process.env['DEBUG'] = namespaces\n  } else {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env['DEBUG']\n  }\n}\n\n/**\n * Load `namespaces`.\n * @return {string} returns the previously persisted debug modes\n */\n\nfunction load() {\n  return process.env['DEBUG']\n}\n\n/**\n * Init logic for `debug` instances.\n * @param {_debug.DebugFunction} debug\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n  debug.inspectOpts = { ...inspectOpts }\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n * @param {Object} v\n * @this {_debug.DebugFunction}\n */\nconst o = function(v) {\n  const opts = {\n    ...this.inspectOpts,\n    colors: this.useColors,\n  }\n  return inspect(v, opts)\n    .replace(/\\s*\\n\\s*/g, ' ')\n}\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n * @param {Object} v\n * @this {_debug.DebugFunction}\n */\nconst O = function(v) {\n  const opts = {\n    ...this.inspectOpts,\n    colors: this.useColors,\n  }\n  return inspect(v, opts)\n}\n\nconst formatters = { 'o': o, 'O': O, ...f }\n\n/** @type {_debug.Env} */\nconst NodeEnv = {\n  init,\n  log,\n  formatArgs,\n  save,\n  load,\n  useColors,\n  colors,\n  inspectOpts,\n  formatters,\n}\n\nexport default NodeEnv\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').DebugFunction} _debug.DebugFunction\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').Env} _debug.Env\n */","class Debug {\n  /**\n   * Create a debugger with the given `namespace`.\n   * @param {_debug.Env} env\n   */\n  constructor(env) {\n    this.colors = env.colors\n    this.formatArgs = env.formatArgs\n    this.inspectOpts = env.inspectOpts\n    this.log = env.log\n    this.save = env.save\n    this.init = env.init\n\n    this.formatters = env.formatters || {}\n\n    /**\n     * Active `debug` instances.\n     * @type {Array<_debug.DebugFunction>}\n     */\n    this.instances = []\n    /**\n\t   * The currently active debug mode names.\n     * @type {Array<!RegExp>}\n\t   */\n    this.names = []\n    /**\n\t   * The currently active names to skip.\n     * @type {Array<!RegExp>}\n\t   */\n    this.skips = []\n  }\n  createDebug() {\n    const debug = this.getDebug()\n\n    // env-specific initialization logic for debug instances\n    if (typeof this.init == 'function') {\n      this.init(debug)\n    }\n\n    this.instances.push(debug)\n    return debug\n  }\n\n  /**\n   * @returns {_debug.DebugFunction}\n   */\n  getDebug() {\n    const formatters = this.formatters\n    const formatArgs = this.formatArgs\n    const log = this.log // comes from the env\n\n    /** @type {number} */\n    let prevTime\n    /** @type {_debug.DebugFunction} */\n    function debug(...args) {\n      if (!debug.enabled) return\n\n      // Set `diff` timestamp\n      const curr = Number(new Date())\n      const time = curr - (prevTime || curr)\n      debug.diff = time\n      debug.prev = prevTime\n      debug.curr = curr\n      prevTime = curr\n\n      args[0] = coerce(args[0])\n\n      if (typeof args[0] != 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O')\n      }\n\n      // Apply any `formatters` transformations\n      let index = 0\n      args[0] = args[0].replace(/%([a-zA-Z%]+)/g, (match, format) => {\n        // If we encounter an escaped % then don't increase the array index\n        if (match == '%%') {\n          return match\n        }\n        index++\n        const formatter = formatters[format]\n        if (formatter) {\n          const val = args[index]\n          match = formatter.call(debug, val)\n\n          // Now we need to remove `args[index]` since it's inlined in the `format`\n          args.splice(index, 1)\n          index--\n        }\n        return match\n      })\n\n      // Apply env-specific formatting (colors, etc.)\n      formatArgs.call(debug, args)\n\n      const logFn = debug.log || log\n      logFn.apply(debug, args)\n    }\n    return debug\n  }\n  /**\n\t * Selects a color for a debug namespace\n\t * @param {string} namespace The namespace string for the for the debug instance to be colored\n\t * @return {number|string} An ANSI color code for the given namespace\n\t */\n  selectColor(namespace) {\n    let hash = 0\n\n    for (let i = 0; i < namespace.length; i++) {\n      hash = ((hash << 5) - hash) + namespace.charCodeAt(i)\n      hash |= 0 // Convert to 32bit integer\n    }\n\n    return this.colors[Math.abs(hash) % this.colors.length]\n  }\n  /**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {string} namespaces\n\t * @api public\n\t */\n  enable(namespaces) {\n    this.save(namespaces)\n\n    this.names = []\n    this.skips = []\n\n    let i\n    const split = (typeof namespaces == 'string' ? namespaces : '').split(/[\\s,]+/)\n    const len = split.length\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?')\n\n      if (namespaces[0] == '-') {\n        this.skips.push(new RegExp('^' + namespaces.substr(1) + '$'))\n      } else {\n        this.names.push(new RegExp('^' + namespaces + '$'))\n      }\n    }\n\n    for (i = 0; i < this.instances.length; i++) {\n      const instance = this.instances[i]\n      instance.enabled = this.enabled(instance.namespace)\n    }\n  }\n  destroy(debug) {\n    const index = this.instances.indexOf(debug)\n    if (index !== -1) {\n      this.instances.splice(index, 1)\n      return true\n    }\n    return false\n  }\n  /**\n\t * Disable debug output.\n\t * @return {string} namespaces\n\t */\n  disable() {\n    const namespaces = [\n      ...this.names.map(toNamespace),\n      ...this.skips.map(toNamespace).map(namespace => '-' + namespace),\n    ].join(',')\n    this.enable('')\n    return namespaces\n  }\n  /**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t * @param {string} name\n\t * @return {boolean}\n\t */\n  enabled(name) {\n    if (name[name.length - 1] == '*') {\n      return true\n    }\n\n    let i\n    let len\n\n    for (i = 0, len = this.skips.length; i < len; i++) {\n      if (this.skips[i].test(name)) {\n        return false\n      }\n    }\n\n    for (i = 0, len = this.names.length; i < len; i++) {\n      if (this.names[i].test(name)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * @param {string} namespace\n * @this {_debug.DebugContext}\n */\nfunction extend(namespace, delimiter) {\n\n}\n\n/**\n * This is the common logic for both the Node.js and web browser implementations of `debug()`.\n * @param {_debug.Env} env\n */\nexport default function setup(env) {\n  const instance = new Debug(env)\n\n  /**\n   * Creates a function to log messages.\n   * @param {string} namespace\n   */\n  function createDebug(namespace) {\n    const debug = instance.createDebug()\n\n    debug.namespace = namespace\n    debug.useColors = env.useColors()\n    debug.enabled = instance.enabled(namespace)\n    debug.color = instance.selectColor(namespace)\n    /** @this {_debug.DebugContext} */\n    debug.destroy = function() {\n      instance.destroy(this)\n    }\n    /** @this {_debug.DebugContext} */\n    debug.extend = function(ns, delimiter) {\n      const newDebug = (this.namespace + (delimiter === undefined ? ':' : delimiter) + ns)\n      newDebug.log = this.log // don't know why this is here\n      return newDebug\n    }\n\n    instance.enable(env.load())\n\n    return debug\n  }\n  return createDebug\n}\n\n/**\n * Convert regexp to namespace.\n *\n * @param {!RegExp} regexp\n * @return {string} namespace\n * @private\n */\nfunction toNamespace(regexp) {\n  return regexp.toString()\n    .substring(2, regexp.toString().length - 2)\n    .replace(/\\.\\*\\?$/, '*')\n}\n\n/**\n * Coerce `val`.\n * @param {!Error|*} val\n * @return {*}\n * @private\n */\nfunction coerce(val) {\n  if (val instanceof Error) {\n    return val.stack || val.message\n  }\n  return val\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Env} _debug.Env\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').DebugFunction} _debug.DebugFunction\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').DebugContext} _debug.DebugContext\n */","import { PassThrough, Transform } from 'stream'\nimport Debug from '@idio/debug'\nimport { c as C, b as B } from 'erte'\n\nconst debug=Debug('nicer')\n\nconst trunc = (s, l = 97) => {\n  let h = s.slice(0, l)\n  if (s.length >= l+3) h += '...'\n  else if (s.length == l+2) h += '..'\n  else if (s.length == l+1) h += '.'\n  return h\n}\n\n/**\n * @param {Buffer} s\n * @param {number} i The length of the boundary (\\r\\n\\r\\n)\n */\nconst splitHeader = (s, i) => {\n  const header = s.slice(0, i)\n  const data = s.slice(i + 4)\n  return { header, data }\n}\n\n/**\n * @param {!Buffer} a\n * @param {!Buffer} b\n */\nconst concatBuffer = (a, b, comment='', z=0) => {\n  if (!a.length) return b\n  if (!b.length) return a\n  const x = ' '.repeat(z)\n  if (comment) comment = `-${comment}`\n  debug('%s<concat%s>', x, comment)\n  const res = Buffer.concat([a, b])\n  debug('%s<concat%s> %f', x, comment, res.length)\n  return res\n}\n\n/**\n * @implements {_nicer.Nicer}\n */\nexport default class Nicer extends Transform {\n  constructor(cfg) {\n    const { readableHighWaterMark, writableHighWaterMark, boundary } = cfg || {}\n    if (!boundary) throw new Error(\"please pass the boundary\")\n    super(/** @type {!stream.TransformOptions} */({\n      // readableHighWaterMark,\n      writableHighWaterMark,\n      readableObjectMode: true,\n    }))\n    /** @type {!Buffer} */\n    this.buffer = Buffer.from('')\n    this.needle = boundary\n    this.BOUNDARY = `--${this.needle}`\n\n    this.state = 'start'\n    /** @type {!Buffer} */\n    this.header = Buffer.from('')\n    this.bodyWritten = 0\n\n    this.bodyStream = null\n  }\n  /**\n   * Stores the header data in internal buffer until it can find `\\r\\n\\r\\n` after which we know that\n   * the body started to be written. The body will finish with the boundary.\n   */\n  writeHeader(data) {\n    if (!data.length) return\n    this.header = concatBuffer(this.header, data, 'header', 6)\n    let i = this.header.indexOf('\\r\\n\\r\\n')\n    if (i != -1) {\n      const { header, data: newData } = splitHeader(this.header, i)\n      this.state = 'reading_body'\n      debug(`    \ud83d\uddd2  Found header at %s, data available <%f>`,\n        C(`${i}`, 'yellow'), newData.length)\n\n      debugHeader(header)\n\n      // if we know this part has finished, we can just flush it wil body as a string...\n      this.bodyStream = new PassThrough()\n      // this.bodyStream = new Readable({\n      //   read() {\n\n      //   },\n      // })\n      // this.bodyWritten = 0\n      this.resetHeader()\n      /** @type {_nicer.Part} */\n      const d = { header, stream: this.bodyStream }\n      this.push(d)\n      this.writeBody(newData)\n    }\n  }\n  resetHeader() {\n    this.header = Buffer.from('')\n  }\n  writeBody(data) {\n    this.bodyWritten += data.length\n    this.bodyStream.write(data)\n    debug('    \ud83d\udcdd  Wrote %f to body', data.length)\n  }\n  _transform(chunk, enc, next) {\n    // console.log('RECEIVED %s', chunk.length)\n    // this is the buffer with padding, so that a part of the boundary does not\n    // end up in the body\n    /*\n     The data that is coming can end half-way through the separator\n     so there is always a length left from the incoming buffers, which\n     equals to the length of the separator - 1\n     This will be handled in the _final call node 8\n    */\n    try {\n      this.buffer = concatBuffer(this.buffer, chunk, 'transform')\n      this.buffer = this.consumeAndUpdate()\n    } catch (err) {\n      next(err)\n      return\n    }\n\n    next(null)\n  }\n  /**\n   * Consumes all bytes in the safe buffer and updates the internal buffer to exclude the safe one leaving only the necessary padding.\n   */\n  consumeAndUpdate() {\n    const { buffer } = this\n    const rest = this.consumeSafe(buffer)\n    const howmuchconsumed = buffer.length - rest.length\n    const left = howmuchconsumed ? this.buffer.slice(howmuchconsumed) : this.buffer\n    debug('one consume safe consumed %f and left %f', howmuchconsumed, left.length)\n    return left\n  }\n  get boundary() {\n    const boundary = this.state == 'start' ? this.BOUNDARY : `\\r\\n${this.BOUNDARY}`\n    return boundary\n  }\n  /**\n   * @param {Buffer} [data]\n   */\n  finishCurrentStream(data) {\n    if (!this.bodyStream) return\n\n    if (data && data.length) this.writeBody(data)\n    debug('    \ud83d\udd12  Closing current data stream, total written: %f', this.bodyWritten)\n    this.bodyStream.push(null)\n    this.bodyStream = null\n    this.bodyWritten = 0\n  }\n  /**\n   * Must make sure to keep some padding so it doesn't end up in the body.\n   * Can disregard the preamble buffer.\n   * @param {Buffer} buffer\n   */\n  consumeSafe(buffer) {\n    // if (!buffer.length) return buffer\n    let i, b\n    let foundSeparator = 0\n    // this will only consume buffer until the after the boundary\n    debug('\ud83d\udd0d  Staring boundary %s scan', C(trunc(this.boundary.trim(), 15), 'red'))\n    const toConsume = []\n\n    while((i = buffer.indexOf(b = this.boundary)) != -1) {\n      foundSeparator++\n      const offset = i + b.length\n\n      const data = buffer.slice(0, i)\n      buffer = buffer.slice(offset)\n\n      // when in here, guaranteed to have a body finished\n      if (this.state == 'start') {\n        debug('  \u2b50  Found starting boundary at index %s', C(`${i}`, 'yellow'))\n        this.state = 'reading_header'\n        continue\n      }\n      debug('  \ud83d\udd1b  Found boundary, data size %fm', data.length)\n      // what if state is reading body\n      if (this.state == 'reading_body') {\n        this.finishCurrentStream(data)\n        this.state = 'finished_body'\n      } else if (this.state == 'reading_header' && this.header.length) {\n        // headerToConsume = data\n        const header = Buffer.concat([this.header, data])\n        debug(`  \ud83d\uddd2  Found header and data of size <%fy>`, header.length)\n        debugHeader(header, 3)\n        toConsume.push(header)\n        this.resetHeader()\n        this.state = 'finished_body'\n        // found end\n      } else\n        toConsume.push(data)\n\n      /**\n       *  Content-Disposition: form-data; name=\"alan\"\n\n          watts\n          --u2KxIV5yF1y+xUspOQCCZopaVgeV6Jxihv35XQJmuTx8X3sh--\n          \"\n       */\n    }\n    toConsume.forEach((d) => {\n      const j = d.indexOf('\\r\\n\\r\\n')\n      if (j == -1) throw new Error('Did not find the end of header before boundary.')\n      const { header, data } = splitHeader(d, j)\n      const stream = new PassThrough()\n      stream.end(data)\n      this.push({ header, stream })\n      this.state = 'finished_body'\n    })\n    // debugger\n\n    // buffer will only be consumed by parts ie until the end of the separator\n    // OR WHEN IT'S a 100% data or header stream\n    // what's left is not handled\n\n    // OR HANDLE IT HERE\n    // -- END\n    // -- PUSH TO THE BODY or HEADER\n    debug('\ud83d\udd0e  Finished boundary scan, buffer of length %f left, separators found: %s',\n      buffer.length, foundSeparator)\n\n    if (this.state == 'finished_body' && checkIsEnd(buffer)) {\n      debug('\u3030\ufe0f  Special case, found %s after the boundary', C('--', 'red'))\n      this.state = 'data-ended'\n      return buffer\n    } else if (this.state == 'finished_body') {\n      this.state = 'reading_header'\n    }\n\n    // we might have a header\n    const canSafelyWrite = this.safeBuffer(buffer)\n    const rest = buffer.slice(canSafelyWrite.length)\n    if (this.state == 'reading_body') {\n      this.writeBody(canSafelyWrite)\n      return rest\n    } else if (this.state == 'reading_header') {\n      this.writeHeader(canSafelyWrite)\n      return rest\n    } else if (this.state == 'start') {\n      return rest\n    }\n    return buffer\n  }\n  /**\n   * Safe buffer is how much we can write confident that what we've written does not contain boundary.\n   * @param {Buffer} buffer\n   */\n  safeBuffer(buffer) {\n    const safeBuffer = buffer.slice(0, Math.max(0, buffer.length - this.boundary.length))\n    return safeBuffer\n  }\n  /**\n   * Final is called with what's left in the buffer at the end. If it doesn't finish property with --boundary--, emit an error.\n   */\n  _final(cb) {\n    if (this.state == 'data-ended') {\n      this.finishCurrentStream()\n      return cb()\n    }\n\n    this.buffer = this.consumeAndUpdate()\n    this.finishCurrentStream()\n\n    const isEnd = checkIsEnd(this.buffer)\n    if (!isEnd) {\n      let b = this.buffer.slice(0, 2).toString()\n      const e = new Error(`Unexpected end of request body, wanted to see \"--\" but saw ${b}.`)\n      cb(e)\n      this.push(e)\n    } else {\n      cb()\n      this.push(null)\n    }\n  }\n}\n\nconst checkIsEnd = (buffer) => {\n  const endsWithDashes = buffer[0] == 45 && buffer[1] == 45\n  return endsWithDashes\n}\n\nconst debugHeader = (header, i = 5) => {\n  if (!/nicer/.test(`${process.env.DEBUG}`)) return\n  const h = trunc(header)\n  h.toString().split(/\\r?\\n/).filter(Boolean).forEach(l => {\n    debug('%s%s', ' '.repeat(i +2), C(B(`${l}`, 'blue'), 'cyan'))\n  })\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').Part} _nicer.Part\n */","import NodeEnv from './node'\nimport setup from './common'\n\n/**\n * Creates a function to log messages.\n * @param {string} namespace\n */\nexport default function(namespace) {\n  if (!namespace) throw new Error('To use debug, pass the namespace.')\n  const node = setup(NodeEnv)\n  const debug = node(namespace)\n  return debug\n}","import '../types/externs'\nimport Nicer from './'\n\nmodule.exports = Nicer"],
"names":["PassThrough","Transform","stream","$jscompDefaultExport","tty","format","inspect","util","val","options","type","length","parse","isFinite","long","msAbs","Math","abs","ms","d","plural","h","m","s","round","Error","JSON","stringify","str","String","match","exec","n","parseFloat","toLowerCase","y","w","name","formatThousandsRegExp","formatDecimalsRegExp","map","pow","value","Number","mag","thousandsSeparator","unitSeparator","decimalPlaces","undefined","fixedDecimals","unit","toFixed","replace","colors","backgroundColors","c","string","color","cc","v","inspectOpts","Object","keys","process","env","filter","key","test","reduce","obj","prop","substring","_","k","toUpperCase","formatters","o","opts","useColors","O","f","NodeEnv","init","debug","log","args","stderr","write","formatArgs","namespace","uc","diff","colorCode","prefix","split","join","push","toISOString","Date","save","namespaces","load","isatty","fd","getDebug","enabled","curr","prevTime","prev","coerce","unshift","index","formatter","call","splice","apply","createDebug","instances","selectColor","hash","i","charCodeAt","enable","names","skips","len","RegExp","substr","instance","Debug","indexOf","stack","message","setup","destroy","debug.destroy","extend","debug.extend","ns","delimiter","newDebug","node","trunc","l","slice","splitHeader","header","data","concatBuffer","a","b","comment","z","x","repeat","res","Buffer","concat","writeBody","bodyWritten","bodyStream","writeHeader","newData","state","C","debugHeader","resetHeader","from","consumeAndUpdate","buffer","rest","consumeSafe","left","howmuchconsumed","foundSeparator","boundary","trim","toConsume","offset","finishCurrentStream","forEach","j","end","canSafelyWrite","safeBuffer","max","Nicer","cfg","writableHighWaterMark","readableObjectMode","needle","BOUNDARY","chunk","enc","next","err","cb","toString","e","DEBUG","Boolean","module","exports"]
}
